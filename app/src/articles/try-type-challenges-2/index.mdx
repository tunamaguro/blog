---
title: "type-challenges ã‚’ã‚„ã£ã¦ã¿ã‚‹(mediumç·¨ãã®1)"
date: "2023-01-07"
slug: "try-type-challenges-2"
emoji: "ğŸ“"
tags: ["tech", "TypeScript"]
---

Typescript ã®ç·´ç¿’ã¨ã—ã¦ type-challenges ã‚’ã‚„ã£ãŸå‚™å¿˜éŒ²ã§ã™ã€‚

[type-challenges ã®ãƒªãƒã‚¸ãƒˆãƒª](https://github.com/type-challenges/type-challenges)

[å‰å›](/articles/try-type-challenges-1/)ã¯ easy ã‚’è§£ãã¾ã—ãŸãŒã€ä»Šå›ã¯ medium ã‚’ã‚„ã£ã¦ã„ãã¾ã™ã€‚

## Get Return Type

Implement the built-in ReturnType\<T> generic without using it.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00002-medium-return-type/README.md)

### è§£ç­”ä¾‹

```typescript
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : never;
```

ReturnType ã¯ T ãŒé–¢æ•°å‹ã®ã¨ãã€ãã®è¿”ã‚Šå€¤ã®å‹ã‚’è¿”ã™ã‚ˆã†ãªå‹ã§ã™ã€‚  
easy ã§ä½¿ç”¨ã—ã¦ã„ãŸ infer ã‚’ä½¿ã£ã¦è§£ãã“ã¨ãŒã§ãã¾ã™ã€‚ãã‚Œã‚’çŸ¥ã£ã¦ã„ã‚Œã°ãã“ã¾ã§é›£ã—ããªã„ã§ã—ã‚‡ã†ã€‚

[Inferring Within Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#inferring-within-conditional-types)

## å•é¡Œå

Implement the built-in Omit\<T, K> generic without using it.

Constructs a type by picking all properties from T and then removing K

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00003-medium-omit/README.md)

### è§£ç­”ä¾‹

```typescript
type MyOmit<T extends object, K extends keyof T> = {
  [P in Exclude<keyof T, K>]: T[P];
};
```

Omit ã¯ K ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ T ã‹ã‚‰å–ã‚Šé™¤ãå‹ã§ã™ã€‚çµ„ã¿è¾¼ã¿å‹ã§ã‚ã‚‹ Exclude ã‚’ä½¿ãˆã°ã€å®¹æ˜“ã«æ›¸ãã“ã¨ãŒã§ãã¾ã™ã€‚  
ã¡ãªã¿ã« Exclude ã¯ä¸ãˆã‚‰ã‚ŒãŸ U ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹å‹ã‚’ T ã‹ã‚‰å–ã‚Šé™¤ãå‹ã§ã™ã€‚è©³ç´°ã«ã¤ã„ã¦ã¯[å‰å›](/articles/try-type-challenges-1/)ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

```typescript
type Exclude<T, U> = T extends U ? never : T;
```

## Readonly 2

Implement a generic MyReadonly2\<T, K> which takes two type argument T and K.

K specify the set of properties of T that should set to Readonly. When K is not provided, it should make all properties readonly just like the normal Readonly\<T>.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00008-medium-readonly-2/README.md)

### è§£ç­”ä¾‹

```typescript
type MyReadonly2<T extends object, K extends keyof T = keyof T> = Omit<T, K> & {
  +readonly [P in K]: T[P];
};
```

ä¸ãˆã‚‰ã‚ŒãŸ T ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã†ã¡ã€K ã«å‰²ã‚Šå½“ã¦ã‚‰ã‚Œã‚‹ã‚‚ã®ã‚’ readonly ã«ã™ã‚‹å•é¡Œã§ã™ã€‚  
ã“ã®å•é¡Œã‚’è§£ãã«ã¯ã€ä»¥ä¸‹ã® 4 å€‹ã®æ©Ÿèƒ½ã‚’çŸ¥ã£ã¦ãŠãå¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

1. [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
1. [Mapping Modifiers](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
1. [Generics](https://www.typescriptlang.org/docs/handbook/2/generics.html)
1. [Intersection Types](https://www.typescriptlang.org/docs/handbook/2/objects.html#intersection-types)

ã¯ã˜ã‚ã¯ç°¡å˜ã«ã€K ã«å‰²ã‚Šå½“ã¦å¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã¿å–ã‚Šå‡ºã™å‹ã‚’è€ƒãˆã¾ã™ã€‚[easy ã§è¡Œã£ãŸ Pick å‹](https://github.com/type-challenges/type-challenges/blob/main/questions/00004-easy-pick/README.md)ãã®ã¾ã¾ã§ã™ã€‚

```typescript
type MyReadonly2<T extends object, K extends keyof T> = { [P in K]: T[P] };
```

ç¶šã„ã¦ã€readonly ã‚’ Mapping Modifiers ã‚’ä½¿ã£ã¦ä»˜ã‘ã¾ã™ã€‚readonly ã®+ã¯ã‚ã£ã¦ã‚‚ãªãã¦ã‚‚å•é¡Œã‚ã‚Šã¾ã›ã‚“ã€‚

```typescript
type MyReadonly2<T extends object, K extends keyof T> = {
  +readonly [P in K]: T[P];
};
```

ã“ã‚Œã§ã¯ã€K ã«å‰²ã‚Šå½“ã¦å¯èƒ½ãªãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã—ã‹ã‚ã‚Šã¾ã›ã‚“ã®ã§ã€ãã‚Œä»¥å¤–ã®å‹ã‚’ Omit ã§å–ã‚Šå‡ºã—ãã‚Œã¨äº¤å·®å‹ã«ã—ã¾ã™ã€‚

```typescript
type MyReadonly2<T extends object, K extends keyof T> = Omit<T, K> & {
  +readonly [P in K]: T[P];
};
```

æœ€å¾Œã«ã€K ãŒä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸéš›ã«ã™ã¹ã¦ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ readonly ã«ã™ã‚‹ãŸã‚ã«ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹å¼•æ•°ã‚’ä¸ãˆã¾ã™ã€‚  
ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹å¼•æ•°ã¯é€šå¸¸ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¼•æ•°ã®ã‚ˆã†ã«ã€ä¸ãˆã‚‰ã‚Œãªã‹ã£ãŸå ´åˆã®å‹ã‚’æŒ‡å®šã™ã‚‹äº‹ãŒã§ãã¾ã™ã€‚
ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦ã¯ä»¥ä¸‹ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚ãŸã ã€[å…¬å¼ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.typescriptlang.org/docs/handbook/2/generics.html)ã§è¨˜è¼‰ã‚’è¦‹ã¤ã‘ã‚‰ã‚Œãªã‹ã£ãŸã®ã§ã€æœ‰å¿—ã®æ–¹ã€…ãŒä½œã‚‰ã‚ŒãŸãƒšãƒ¼ã‚¸ã§ã™ã€‚

[ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå‹å¼•æ•°](https://typescriptbook.jp/reference/generics/default-type-parameter)

```typescript
type MyReadonly2<T extends object, K extends keyof T = keyof T> = Omit<T, K> & {
  +readonly [P in K]: T[P];
};
```

## Deep Readonly

Implement a generic DeepReadonly\<T> which make every parameter of an object - and its sub-objects recursively - readonly.

You can assume that we are only dealing with Objects in this challenge. Arrays, Functions, Classes and so on do not need to be taken into consideration. However, you can still challenge yourself by covering as many different cases as possible.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00009-medium-deep-readonly/README.md)

### è§£ç­”ä¾‹

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: keyof T[P] extends never ? T[P] : DeepReadonly<T[P]>;
};
```

å­è¦ç´ ã‚’å«ã‚€å…¨ã¦ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ readonly ã«ã™ã‚‹å•é¡Œã§ã™ã€‚ã¯ã˜ã‚ã«ã€é€šå¸¸ã® Readonly ã‚’è€ƒãˆã¾ã™ã€‚

```typescript
type DeepReadonly<T extends object> = { readonly [P in keyof T]: T[P] };
```

T ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£(ã¤ã¾ã‚Š T[P])ãŒã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã®å ´åˆã€ãã‚Œã‚‚ readonly ã«ã—ãŸã„ã®ã§å†å¸°ã•ã›ã¾ã™ã€‚

```typescript
type DeepReadonly<T extends object> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};
```

ã—ã‹ã—ã“ã‚Œã§ã¯ T[P]ãŒé…åˆ—ã®å ´åˆã« Expected1 ã®ã‚ˆã†ã«é…åˆ—ã‚’ readonly ã«ã§ãã¾ã›ã‚“ã€‚

```typescript
type Expected1 = {
  readonly a: () => 22;
  readonly b: string;
  readonly c: {
    readonly d: boolean;
    readonly e: {
      readonly g: {
        readonly h: {
          readonly i: true;
          readonly j: "string";
        };
        readonly k: "hello";
      };
      // ã“ã“ã‹ã‚‰
      readonly l: readonly [
        "hi",
        {
          readonly m: readonly ["hey"];
        }
      ];
      // ã“ã“ã¾ã§
    };
  };
};
```

ãã“ã§ã€ã™ã“ã—ç™ºæƒ³ã‚’å¤‰ãˆ keyof T[P]ãŒ never ã§ã¯ãªã„ã¨ã===Array ã‚„ object ã§ã‚ã‚‹ã¨ãã«å†å¸°ã•ã›ã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: keyof T[P] extends never ? T[P] : DeepReadonly<T[P]>;
};
```

ã“ã‚Œã§ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’é€šã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚
ãŸã ã€string ã‚„ number ã‚’ä¸ãˆãŸéš›ã®æŒ™å‹•ãŒã‚¤ãƒ¡ãƒ¼ã‚¸ã—ã«ãã„ã®ã§ã“ã“ã¾ã§ã‚„ã‚‰ãªãã¦ã‚‚è‰¯ã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

## Tuple to Union

Implement a generic TupleToUnion\<T> which covers the values of a tuple to its values union.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00010-medium-tuple-to-union/README.md)

### è§£ç­”ä¾‹

```typescript
type TupleToUnion<T extends any[]> = T[number];
```

ã‚¿ãƒ—ãƒ«ã®è¦ç´ ã‚’å–ã‚Šå‡ºã—ã¦ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã«ã™ã‚‹å•é¡Œã§ã™ã€‚  
easy ã®[Tuple to Object](https://github.com/type-challenges/type-challenges/blob/main/questions/00011-easy-tuple-to-object/README.md)ãŒè§£ã‘ã¦ã„ã‚Œã°ç°¡å˜ã«è§£ã‘ã‚‹ã¨æ€ã„ã¾ã™ã€‚

## Chainable Options

Chainable options are commonly used in Javascript. But when we switch to TypeScript, can you properly type it?

In this challenge, you need to type an object or a class - whatever you like - to provide two function option(key, value) and get(). In option, you can extend the current config type by the given key and value. We should about to access the final result via get.

For example

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00012-medium-chainable-options/README.md)

### è§£ç­”ä¾‹

```typescript
type Chainable<V = {}> = {
  option<T extends string, U extends any>(
    key: T extends keyof V ? never : T,
    value: U
  ): Chainable<{ [P in T]: U } & Omit<V, T>>;
  get(): V;
};
```

ãƒã‚§ãƒ¼ãƒ³ã§ãã‚‹ã‚ˆã†ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã‚’ä½œã‚‹å•é¡Œã€‚ã¨ã‚Šã‚ãˆãšã€ã§ãã‚‹ã“ã¨ã‹ã‚‰ã‚„ã£ã¦ã¿ã‚‹ã®ãŒè‰¯ã„ã¨æ€ã„ã¾ã™ã€‚  
ã¯ã˜ã‚ã«ã€å¼•æ•° key ã¨ value ã®å‹ãŒã‚ã‹ã‚‰ãªã„ã¨ã©ã†ã—ã‚ˆã†ã‚‚ãªã„ã®ã§ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’ä»˜ã‘ã¾ã™ã€‚ã¨ã‚Šã‚ãˆãšã§ã€è¿”ã‚Šå€¤ã¯ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ T ãŒ U ã§ã‚ã‚‹ã‚ˆã†ãªå‹ã«ã—ã¦ãŠãã¾ã™ã€‚

```typescript
type Chainable = {
  option<T extends string, U extends any>(key: T, value: U): { [P in T]: U };
  get(): any;
};
```

æ¬¡ã«ã€Chainable ã¯ option ã®è¿”ã‚Šå€¤ã®å‹ã‚’è¦šãˆã¦ãŠãå¿…è¦ãŒã‚ã‚‹ã®ã§ã€ãã‚Œç”¨ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã‚’å¢—ã‚„ã—ã¾ã™ã€‚  
åŒæ™‚ã«ã€option=>Chainable ã§ã‚ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã§ãã®ã‚ˆã†ã«æ›¸ãæ›ãˆã€ã¤ã„ã§ã« get=>V ã«ã—ã¦ãŠãã¾ã™ã€‚

```typescript
type Chainable<V = {}> = {
  option<T extends string, U extends any>(
    key: T,
    value: U
  ): Chainable<{ [P in T]: U } & V>;
  get(): V;
};
```

ã“ã‚Œã§ V ã«ã¯ option ã§å‘¼ã³å‡ºã—ãŸè¨˜éŒ²ãŒæ®‹ã•ã‚Œã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã—ãŸã€‚  
ç¾çŠ¶ã§ã¯ã€result3 ã® name ãŒ string|number ã«ãªã£ã¦ã—ã¾ã£ã¦ã„ã‚‹ã®ã§ã€åŒã˜ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å ´åˆãã‚Œã‚’å¿˜ã‚Œã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚  
ã“ã‚Œã«ã¯ Utility Types ã® Omit ã‚’ä½¿ã†ã¨æ¥½ã ã¨æ€ã„ã¾ã™ã€‚

[Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

```typescript
type Chainable<V = {}> = {
  option<T extends string, U extends any>(
    key: T,
    value: U
  ): Chainable<{ [P in T]: U } & Omit<V, T>>;
  get(): V;
};
```

æœ€å¾Œã«åŒã˜ key ã§å‘¼ã°ã‚ŒãŸéš›ã«ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚ã“ã‚Œã¯è¨€ã„æ›ãˆã‚‹ã¨ T ãŒ keyof V ã‚’æº€ãŸã™ã¨ã„ã†ã“ã¨ãªã®ã§ã€
ãã®å ´åˆã« key ã®å‹ãŒ never ã«ãªã‚‹ã‚ˆã†ã«æ›¸ãæ›ãˆã¾ã™ã€‚

```typescript
type Chainable<V = {}> = {
  option<T extends string, U extends any>(
    key: T extends keyof V ? never : T,
    value: U
  ): Chainable<{ [P in T]: U } & Omit<V, T>>;
  get(): V;
};
```

ä¸‰é …æ¼”ç®—å­ãŒå¤§ä½“ã©ã“ã§ã‚‚ä½¿ãˆã‚‹ã®ãŒæ„å¤–ã§ã™ã­ã€‚

## Last of Array

Implement a generic Last\<T> that takes an Array T and returns its last element.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00015-medium-last/README.md)

### è§£ç­”ä¾‹

```typescript
type Last<T extends any[]> = T extends [...any, infer R] ? R : never;
```

é…åˆ—ã®æœ€å¾Œã®å‹ã‚’å–å¾—ã™ã‚‹å•é¡Œã§ã™ã€‚ã¯ã˜ã‚ã¯ä¸‹ã®ã‚ˆã†ã«ã‚„ã‚ŠãŸããªã‚Šã¾ã™ãŒã€

```typescript
type Last<T extends any[]> = T[T["length"]-1]
```

å‹ã®å››å‰‡æ¼”ç®—ã¯é€šå¸¸ã® javascript ã®ã‚ˆã†ã«ã¯ã§ãã¾ã›ã‚“ã€‚  
ãã“ã§ã€é…åˆ—ã‚’ 1 ã¤ãšã¤å–ã£ã¦ã„ã£ã¦æœ€å¾Œã®è¦ç´ ã‚’å–ã‚Šå‡ºã™ã¨ã„ã†ã“ã¨ã‚’è€ƒãˆã¦ã¿ã¾ã™ã€‚ã“ã‚Œã«ã¯[variadic-tuple-types](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-0.html#variadic-tuple-types)
ãŒä½¿ãˆã¾ã™ã€‚é›‘ã«è¨€ã†ã¨ã€ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ¼”ç®—å­ã‚’å‹ã§ã‚‚ä½¿ã†ã“ã¨ãŒã§ãã¾ã™ã€‚ãã†ã—ãŸã‚‰ã€æœ€å¾Œã®å‹ã‚’ infer ã§å–å¾—ã™ã‚Œã°å•é¡Œã‚’è§£ãã“ã¨ãŒã§ãã¾ã—ãŸã€‚  
javascript ã§ã¯ä¸Šã®ã‚ˆã†ãªæ§‹æ–‡ã¯ã‚¨ãƒ©ãƒ¼ã«ãªã£ã¦ã—ã¾ã†ã®ã§ã€æ€ã„ã¤ãã«ãã„ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ã€‚

## Pop

> TypeScript 4.0 is recommended in this challenge

Implement a generic Pop\<T> that takes an Array T and returns an Array without it's last element.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00016-medium-pop/README.md)

### è§£ç­”ä¾‹

```typescript
type Pop<T extends any[]> = T extends [...infer R, any] ? R : [];
```

é…åˆ—å‹ã‹ã‚‰æœ€å¾Œã®è¦ç´ ã‚’å–ã‚Šé™¤ãå‹ã‚’ä½œã‚‹å•é¡Œã§ã™ã€‚  
ä¸Šã® Last ãŒç†è§£ã§ãã¦ã„ã‚Œã°ã¤ã¾ãšãã“ã¨ã¯ãªã„ã¨æ€ã„ã¾ã™ã€‚

## Promise.all

Type the function PromiseAll that accepts an array of PromiseLike objects, the returning value should be Promise\<T> where T is the resolved result array.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00020-medium-promise-all/README.md)

### è§£ç­”ä¾‹

```typescript
declare function PromiseAll<T extends any[]>(
  values: readonly [...T]
): Promise<{
  [P in keyof T]: Awaited<T[P]>;
}>;
```

PromiseAll ã¯é…åˆ—ã‚’å—ã‘å–ã‚Šãã‚Œã‚’ã€Promise ã§ãƒ©ãƒƒãƒ—ã—ãŸã‚‚ã®ã‚’è¿”ã™é–¢æ•°ã§ã™ã€‚ã¨ã‚Šã‚ãˆãšã€ãã“ã‹ã‚‰æ›¸ã„ã¦ã„ãã¾ã™ã€‚

```typescript
declare function PromiseAll<T extends any[]>(values: [...T]): Promise<T>;
```

ã‚¨ãƒ©ãƒ¼ãŒå‡ºã¦ãã¾ã—ãŸã€‚ã‚¨ãƒ©ãƒ¼ã‚’è¦‹ã‚‹ã¨*values ã« readonly ãŒè¶³ã‚Šãªã„ã‚ˆ!!*ã¨æ›¸ã„ã¦ã‚ã‚‹ã®ã§ä»˜ã‘åŠ ãˆã¾ã™ã€‚

```typescript
declare function PromiseAll<T extends any[]>(
  values: readonly [...T]
): Promise<T>;
```

æ®‹ã£ã¦ã„ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’è¦‹ã‚‹ã¨ã€é…åˆ—å†…ã® Promise ã‚’ã‚¢ãƒ³ãƒ©ãƒƒãƒ—ã—ã¦è¿”ã™å¿…è¦ãŒã‚ã‚‹ã‚ˆã†ã§ã™ã€‚  
extends Promise\<infer R>...ã¨ã—ã¦ã‚‚ã„ã„ã§ã™ãŒã€é¢å€’ãªã®ã§ Utility Types ã® Awaited ã‚’ä½¿ã„ã¾ã™ã€‚

[Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

```typescript
declare function PromiseAll<T extends any[]>(
  values: readonly [...T]
): Promise<{
  [P in keyof T]: Awaited<T[P]>;
}>;
```

## Type Lookup

Sometimes, you may want to lookup for a type in a union to by their attributes.

In this challenge, we would like to get the corresponding type by searching for the common type field in the union Cat | Dog. In other words, we will expect to get Dog for LookUp\<Dog | Cat, 'dog'> and Cat for LookUp\<Dog | Cat, 'cat'> in the following example.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00062-medium-type-lookup/README.md)

### è§£ç­”ä¾‹

```typescript
type LookUp<U, T> = U extends { type: T } ? U : never;
```

ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‹ã‚‰ç‰¹å®šã®è¦ç´ ã‚’ä½¿ã£ã¦å‹ã‚’å–ã‚Šå‡ºã™å•é¡Œã§ã™ã€‚  
easy ã§ã‚‚å–ã‚Šæ‰±ã£ãŸ Conditional Types ã«ã‚ˆã‚‹å‹ã®åˆ†é…ã‚’ä½¿ã£ã¦è§£ãã“ã¨ãŒã§ãã¾ã™ã€‚

[åˆ†é…ã®è¨˜è¼‰éƒ¨åˆ†](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

```typescript
type LookUp<U, T> = U extends { type: T } ? U : never;

interface Cat {
  type: "cat";
  breeds: "Abyssinian" | "Shorthair" | "Curl" | "Bengal";
}

interface Dog {
  type: "dog";
  breeds: "Hound" | "Brittany" | "Bulldog" | "Boxer";
  color: "brown" | "white" | "black";
}

type Animal = Cat | Dog;

type A = LookUp<Animal, "dog">; // Dog
// Animal => Cat | Dog
// => never | Dog
// => Dog
```

## Trim Left

Implement TrimLeft\<T> which takes an exact string type and returns a new string with the whitespace beginning removed.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00106-medium-trimleft/README.md)

### è§£ç­”ä¾‹

```typescript
type TrimLeft<S extends string> = S extends `${" " | "\n" | "\t"}${infer R}`
  ? TrimLeft<R>
  : S;
```

æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’å—ã‘å–ã‚Šå…ˆé ­ã®ç©ºç™½ã‚’å‰Šé™¤ã—ãŸæ–°ã—ã„æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’è¿”ã™å•é¡Œã§ã™ã€‚  
ã¨ã‚Šã‚ãˆãšäºˆæƒ³ã§å‹ã‚’æ›¸ãã¨ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†ã‹ã€‚

```typescript
type TrimLeft<S extends string> = ç©ºç™½ã‚’å‰Šé™¤ã™ã‚‹å‡¦ç†
  ? TrimLeft<R>
  : S;
```

ã“ã®ç©ºç™½ã‚’å‰Šé™¤ã™ã‚‹å‡¦ç†ã«ã¯ Template Literal Types ã‚’ä½¿ã†äº‹ãŒã§ãã¾ã™ã€‚

[Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

ã“ã‚Œã‚’ç”¨ã„ã‚‹ã¨ä¸‹ã®ã‚ˆã†ã«æ›¸ã‘ã‚‹ã§ã—ã‚‡ã†ã€‚

```typescript
type TrimLeft<S extends string> = S extends ` ${infer R}` ? TrimLeft<R> : S;
```

ã—ã‹ã—ã“ã‚Œã§ã¯ã„ãã¤ã‹ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã§ãƒ‘ã‚¹ã—ãªã„ã‚ˆã†ã§ã™ã€‚ã‚ˆãè¦‹ã‚‹ã¨" "ã ã‘ã§ãªã"\n"ã‚„"\t"ã‚‚å«ã¾ã‚Œã¦ã„ã¾ã™ã€‚  
å¬‰ã—ã„ã“ã¨ã«ã€Union å‹ã‚’ Template Literal Types ã§ä½¿ã†ã¨å¯èƒ½æ€§ã®ã‚ã‚‹å…¨ã¦ã®æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã«å¤‰æ›ã—ã¦ãã‚Œã¾ã™ã€‚  
ãªã®ã§ã€extends ...extends...ã¨åœ°ç„ã®ã‚ˆã†ã«ä½•å€‹ã‚‚æ›¸ãå¿…è¦ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

```typescript
// `${" " | "\n" | "\t"}${infer R}` = ` ${infer R}` | `\n${infer R}` | `\t${infer R}`;
type TrimLeft<S extends string> = S extends `${" " | "\n" | "\t"}${infer R}`
  ? TrimLeft<R>
  : S;
```

## Trim

Implement Trim\<T> which takes an exact string type and returns a new string with the whitespace from both ends removed.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00108-medium-trim/README.md)

### è§£ç­”ä¾‹

```typescript
type space = " " | "\n" | "\t";
type TrimLeft<S extends string> = S extends `${space}${infer R}`
  ? TrimLeft<R>
  : S;
type TrimRight<S extends string> = S extends `${infer R}${space}`
  ? TrimRight<R>
  : S;
type Trim<S extends string> = TrimLeft<TrimRight<S>>;
```

TrimRight ã®ä¸¡ç«¯ç‰ˆã§ã™ã€‚ç‰¹ã«è¨€ã†ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚

## Capitalize

Implement Capitalize\<T> which converts the first letter of a string to uppercase and leave the rest as-is.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00110-medium-capitalize/README.md)

### è§£ç­”ä¾‹

```typescript
type MyCapitalize<S extends string> = S extends `${infer R}${infer U}`
  ? `${Uppercase<R>}${U}`
  : Uppercase<S>;
```

å…ˆé ­ã®æ–‡å­—ã‚’å¤§æ–‡å­—ã«ã™ã‚‹å•é¡Œã§ã™ã€‚ã“ã‚Œã‚’è¡Œã†ã«ã¯ Intrinsic String Manipulation Types ãŒå¿…è¦ã§ã™ã€‚

[Intrinsic String Manipulation Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types)

Intrinsic String Manipulation Types ã¯æ–‡å­—åˆ—æ“ä½œã§åˆ©ç”¨ã§ãã‚‹å‹ã§ã™ã€‚ã“ã‚Œã¯ typescript ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã«çµ„ã¿è¾¼ã¾ã‚Œã¦ãŠã‚Šã€typescript ã®å‹å®šç¾©ãƒ•ã‚¡ã‚¤ãƒ«ã«ã¯å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚  
ä»®ã« Intrinsic String Manipulation Types ã‚’ä½¿ã‚ãªã„ã¨ã—ãŸã‚‰ä»¥ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†ã‹ã€‚

```typescript
type Chars = { a: "A"; b: "B",... };
type MyCapitalize<S extends string> = S extends `${infer R}${infer U}`
  ? `${R extends keyof Chars?Chars[R]:R}${U}`
  : S;
```

å‹•ä½œç¢ºèªã¯ã—ã¦ãªã„ã®ã§å„è‡ªã§ç¢ºã‹ã‚ã¦ã¿ã¦ãã ã•ã„ã€‚

## Replace

Implement Replace\<S, From, To> which replace the string From with To once in the given string S

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00116-medium-replace/README.md)

### è§£ç­”ä¾‹

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = From extends ""
  ? S
  : S extends `${infer L}${From}${infer R}`
  ? `${L}${To}${R}`
  : S;
```

ã¨ã‚Šã‚ãˆãšå‹ã‚’æ›¸ãã¨ä¸‹ã®ã‚ˆã†ã«ãªã‚‹ã§ã—ã‚‡ã†ã‹ã€‚

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = S extends `${infer L}${From}${infer R}` ? `${L}${To}${R}` : S;
```

ã—ã‹ã—ã€ã“ã‚Œã§ã¯ From ã«""ãŒä¸ãˆã‚‰ã‚ŒãŸã¨ãã«ã‚¨ãƒ©ãƒ¼ã«ãªã£ã¦ã—ã¾ã„ã¾ã™ã€‚

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = S extends `${infer L}${From}${infer R}` ? `${L}${To}${R}` : S;

type A = Replace<"foobarbar", "", "foo">; // "ffoooobarbar"
```

ã“ã‚Œã¯ãƒãƒƒãƒã—ãªã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã¨ãã€1 æ–‡å­—ã®ã¿åˆ‡ã‚Šå–ã‚‹ã¨ã„ã†ä»•æ§˜ã«ãªã£ã¦ã„ã‚‹ãŸã‚ã§ã™ã€‚  
ãã“ã§ã€From ãŒ""ã ã£ãŸã¨ãã«ã¯ã€ã•ã£ã•ã¨ S ã‚’è¿”ã™ã‚ˆã†ã«ã—ã¾ã™ã€‚

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = From extends ""
  ? S
  : S extends `${infer L}${From}${infer R}`
  ? `${L}${To}${R}`
  : S;
```

æ¡ä»¶åˆ†å²ã®æ–¹æ³•ãŒä¸‰é …æ¼”ç®—å­ã®ã‚ˆã†ãª extends ã—ã‹ãªã„ãŸã‚ã«ã€éå¸¸ã«è¦‹ã«ãã„ã§ã™ã­ã€‚

## ReplaceAll

Implement ReplaceAll\<S, From, To> which replace the all the substring From with To in the given string S

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00119-medium-replaceall/README.md)

### è§£ç­”ä¾‹

```typescript
type ReplaceAll<
  S extends string,
  From extends string,
  To extends string
> = From extends ""
  ? S
  : S extends `${infer L}${From}${infer R}`
  ? `${L}${To}${ReplaceAll<R, From, To>}`
  : S;
```

å…ˆç¨‹ã® Replace ã‚’ã™ã¹ã¦ã®æ–‡å­—åˆ—ã§è¡Œã„ã¾ã™ã€‚  
infer ã‚’ä½¿ã£ãŸå ´åˆæœ€çŸ­ã®æ–‡å­—åˆ—ãŒè¿”ã£ã¦ãã¾ã™(è¦å‡ºå…¸)ã€‚ã—ãŸãŒã£ã¦ã€R ã«å¯¾ã—ã¦å†å¸°çš„ã«å‡¦ç†ã‚’ã™ã‚‹ã“ã¨ã§ã™ã¹ã¦ã® From ã«å¯¾ã—ã¦å¤‰æ›ã‚’ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

ä¸‹ã®ä¾‹ã ã¨å‡¦ç†ãŒã§ããªããªã‚‹ã¾ã§ãƒ«ãƒ¼ãƒ—ã—ã¦ã—ã¾ã†ã®ã§ã€ä»Šå›ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’ãƒ‘ã‚¹ã—ã¾ã›ã‚“ã€‚

```typescript
type Replace<
  S extends string,
  From extends string,
  To extends string
> = From extends ""
  ? S
  : S extends `${infer L}${From}${infer R}`
  ? `${L}${To}${R}`
  : S;

type ReplaceAll<
  S extends string,
  From extends string,
  To extends string
> = S extends Replace<S, From, To>
  ? S
  : ReplaceAll<Replace<S, From, To>, From, To>;

type A = ReplaceAll<"foobarfoobar", "ob", "b">; // "fbarfbar"
```

## Append Argument

For given function type Fn, and any type A (any in this context means we don't restrict the type, and I don't have in mind any type ğŸ˜‰) create a generic type which will take Fn as the first argument, A as the second, and will produce function type G which will be the same as Fn but with appended argument A as a last one.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00191-medium-append-argument/README.md)

### è§£ç­”ä¾‹

```typescript
type AppendArgument<Fn extends (...args: any) => any, A> = Fn extends (
  ...args: infer R
) => infer S
  ? (...args: [...R, A]) => S
  : never;
```

å¼•æ•°ã‚’å¢—ã‚„ã™å•é¡Œã§ã™ã€‚ãŠãŠã‹ãŸäºˆæƒ³é€šã‚Šã®è§£ç­”ã ã¨æ€ã„ã¾ã™ã€‚  
...typescript ã®å‹ã§ã¯å¼•æ•°åã®åŒºåˆ¥ã¯ã—ã¦ã„ãªã„ã‚ˆã†ã§ã™ã€‚javascript ã®ä»•æ§˜é€šã‚Šã§ã™ã­ã€‚

## Permutation

Implement permutation type that transforms union types into the array that includes permutations of unions.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00296-medium-permutation/README.md)

### è§£ç­”ä¾‹

```typescript
type Permutation<T, U = T> = [U] extends [never]
  ? []
  : T extends never
  ? []
  : [T, ...Permutation<Exclude<U, T>>];
```

ã²ã¨ã¾ãšã€ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‚’é…åˆ—ã«ã—ã¾ã™ã€‚ãã®ãŸã‚ã« Conditional Types ã‚’åˆ©ç”¨ã—ã¾ã™ã€‚

[åˆ†é…ã®è¨˜è¼‰éƒ¨åˆ†](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)

```typescript
type Permutation<T> = T extends never ? never : [T];

type A = Permutation<"A" | "B" | "C">; // ["A"] | ["B"] | ["C"]
```

ã™ã‚‹ã¨ã€T ã‚’ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‚’æ§‹æˆã™ã‚‹å‹ã”ã¨ã«åˆ†è§£ã§ãã¾ã—ãŸã€‚æ®‹ã‚Šã¯ã€ä¸‹ã®ã‚ˆã†ã«ãªã‚Œã°è‰¯ã•ãã†ã§ã™ã€‚

```typescript
type Permutation<T> = T extends never ? never : [T, ...Permutation<ä½•ã‹>];

type A = Permutation<"A" | "B" | "C">;
```

ã“ã“ã§ã€å‹å¼•æ•° U ã§ T ã®ã‚³ãƒ”ãƒ¼ã‚’å–ã‚Šã€Permutation\<Exclude\<U,T>>ã®ã‚ˆã†ã«ã—ã¦ã¿ã¾ã™ã€‚

```typescript
type Permutation<T, U = T> = T extends never
  ? []
  : [T, ...Permutation<Exclude<U, T>>];

type A = Permutation<"A" | "B" | "C">; // never
```

ãªã«ã‹ã®éƒ½åˆãŒè‰¯ããªã„ã‚ˆã†ã§ã™ã€‚è©¦è¡ŒéŒ¯èª¤ã—ã¦ã„ã‚‹ã¨ä¸‹ã®ã‚ˆã†ãªå½¢ã«ãªã‚Šã¾ã—ãŸã€‚

```typescript
type Permutation<T, U = T> = U extends never
  ? []
  : [T] extends [never]
  ? []
  : [U, Permutation<Exclude<T, U>>];

type A = Permutation<"A" | "B" | "C">; // ["A", ["B", ["C", never]] | ["C", ["B", never]]] | ["B", ["A", ["C", never]] | ["C", ["A", never]]] | ["C", ["A", ["B", never]] | ["B", ["A", never]]]
```

é…åˆ—ã‚’ãƒ•ãƒ©ãƒƒãƒˆã«ã—ãŸã‚‰è‰¯ã•ãã†ãªã®ã§ã€T ã¨ U ã®é †ç•ªã‚’å…¥ã‚Œæ›¿ãˆæ›´ã«ã‚¹ãƒ—ãƒ¬ãƒƒãƒ‰æ¼”ç®—å­ã§å±•é–‹ã—ã¾ã™ã€‚

```typescript
type Permutation<T, U = T> = [U] extends [never]
  ? []
  : T extends never
  ? []
  : [T, ...Permutation<Exclude<U, T>>];

type A = Permutation<"A" | "B" | "C">; // ["A", "B", "C"] | ["A", "C", "B"] | ["B", "A", "C"] | ["B", "C", "A"] | ["C", "A", "B"] | ["C", "B", "A"]
```

æ­£ç›´ã€ãªãœã“ã‚Œã§å‹•ã„ã¦ã„ã‚‹ã®ã‹ã‚ˆãã‚ã‹ã£ã¦ã„ãªã„ã®ã§ã¾ãŸã©ã“ã‹ã§è¨˜äº‹ã«ã—ã¦ã¾ã¨ã‚ã¾ã™ã€‚

## Length of String

Compute the length of a string literal, which behaves like String#length.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00298-medium-length-of-string/README.md)

### è§£ç­”ä¾‹

```typescript
type LengthOfString<S extends string, T extends any[] = []> = S extends ""
  ? T["length"]
  : S extends `${infer L}${infer R}`
  ? LengthOfString<R, [...T, L]>
  : never;
```

æ–‡å­—æ•°ã‚’å‹ã¨ã—ã¦å–å¾—ã™ã‚‹å•é¡Œã§ã™ã€‚  
å˜ç´”ã« S["lenght"]ã¨ã™ã‚Œã°è‰¯ã•ãã†ã§ã™ãŒã€number ãŒè¿”ã£ã¦ãã¦ã—ã¾ã„ã¾ã™ã€‚

```typescript
type LengthOfString<S extends string> = S["length"];

type A = LengthOfString<"">; // number
```

å°‘ã—è€ƒãˆæ–¹ã‚’å¤‰ãˆã€1 æ–‡å­—ãšã¤å‰Šé™¤ã—ã¦ã„ããã®å›æ•°ã‚’ã‚¿ãƒ—ãƒ«ã¨ã—ã¦æŒã£ã¦ãŠãã€ç©ºã«ãªã£ãŸéš›ã«ã‚¿ãƒ—ãƒ«["length"]ã‚’è¿”ã™ã“ã¨ã«ã—ã¾ã™ã€‚  
ã“ã†ã™ã‚‹ã“ã¨ã§ã€æ–‡å­—æ•°ã‚’å‹ã¨ã—ã¦å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚

## Flatten

In this challenge, you would need to write a type that takes an array and emitted the flatten array type.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00459-medium-flatten/README.md)

### è§£ç­”ä¾‹

```typescript
type Flatten<T extends any[]> = T extends [infer R, ...infer S]
  ? R extends any[]
    ? [...Flatten<R>, ...Flatten<S>]
    : [R, ...Flatten<S>]
  : [];
```

å‹ã®ãƒ•ãƒ©ãƒƒãƒˆã‚’è¡Œã†å•é¡Œã§ã™ã€‚  
ä¸Šã®å•é¡Œã¨åŒã˜ã‚ˆã†ã«å·¦ã‹ã‚‰ 1 è¦ç´ ãšã¤é…åˆ—ã‹ã©ã†ã‹æ¤œè¨¼ã—ã€é…åˆ—ãªã‚‰å±•é–‹ã€ãã†ã§ãªã‘ã‚Œã°ã‚¿ãƒ—ãƒ«è¦ç´ ã¨ã—ã¦é…ç½®ã‚’ç¹°ã‚Šè¿”ã—è¡Œã„ã¾ã™ã€‚

## Append to object

Implement a type that adds a new field to the interface. The type takes the three arguments. The output should be an object with the new field.

For example

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-append-to-object/README.md)

### è§£ç­”ä¾‹

```typescript
type AppendToObject<T, U extends string, V> = {
  [P in keyof T | U]: P extends keyof T ? T[P] : V;
};
```

äº¤å·®å‹ã§ã¯ãªãã€ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’å¢—ã‚„ã™å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```typescript
type AppendToObject<T, U extends string, V> = { [P in U]: V } & T;

type test3 = {
  key: "cow";
  value: "yellow";
  sun: false;
};

// A = {
//     isMotherRussia: false | undefined;
// } & test3
type A = AppendToObject<test3, "isMotherRussia", false | undefined>;
```

## Absolute

Implement the Absolute type. A type that take string, number or bigint. The output should be a positive number string

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00529-medium-absolute/README.md)

### è§£ç­”ä¾‹

```typescript
type Absolute<T extends number | string | bigint> = `${T}` extends `-${infer R}`
  ? R
  : `${T}`;
```

ä»Šå›ã®å•é¡Œã§é‡è¦ãªç‚¹ã¯ã€Absolute\<-100>ãŒ 100 ã§ã¯ãªã"100"ã‚’è¿”ã™ã“ã¨ã§ã™ã€‚ã¤ã¾ã‚Šã€æ•°å€¤å‹ã§ã¯ãªãæ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’è¿”ã™ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã‘ã‚Œã°ã€è§£ã‘ã‚‹ã¨æ€ã„ã¾ã™ã€‚

[Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html)

## String to Union

Implement the String to Union type. Type take string argument. The output should be a union of input letters

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00531-medium-string-to-union/README.md)

### è§£ç­”ä¾‹

```typescript
type StringToUnion<T extends string> = T extends `${infer R}${infer S}`
  ? R | StringToUnion<S>
  : never;
```

æ–‡å­—åˆ—ã®å…ˆé ­ã‹ã‚‰ 1 æ–‡å­—ãšã¤å–å¾—ã—ã€ãã‚Œã‚’ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã«æŠ¼ã—è¾¼ã¿ã¾ã™ã€‚never å‹ã‚’ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã«å–ã£ã¦ã‚‚å‹ã¯å¤‰åŒ–ã—ã¾ã›ã‚“ã€‚

```typescript
type A = number | never; // number
```

## Merge

Merge two types into a new type. Keys of the second type overrides keys of the first type.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00599-medium-merge/README.md)

### è§£ç­”ä¾‹

```typescript
type Merge<F, S> = {
  [P in keyof F | keyof S]: P extends keyof S
    ? S[P]
    : P extends keyof F
    ? F[P]
    : never;
};
```

[Append to object](https://github.com/type-challenges/type-challenges/blob/main/questions/00527-medium-append-to-object/README.md)
ã¨åŒã˜å‡¦ç†ã‚’ã—ã¾ã—ã‚‡ã†ã€‚ãŸã ã—ã€ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’è¦‹ã‚‹ã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®å„ªå…ˆåº¦ã¯ S\>F ã¨ãªã£ã¦ã„ã‚‹ã®ã§ã€æ¡ä»¶åˆ†å²ã®é †ç•ªã«ã¯æ³¨æ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

## KebabCase

Replace the camelCase or PascalCase string with kebab-case.

FooBarBaz -> foo-bar-baz

[å•é¡Œ](https://github.com/type-challenges/type-challenges/issues/21332)

### è§£ç­”ä¾‹

```typescript
type KebabCase<S extends string> = S extends `${infer L}${infer R}`
  ? R extends Uncapitalize<R>
    ? `${Lowercase<L>}${KebabCase<R>}`
    : `${Lowercase<L>}-${KebabCase<R>}`
  : S;
```

camelCase åŠã³ CamelCase ã‚’ kebab-case ã«å¤‰æ›ã™ã‚‹å•é¡Œã§ã™ã€‚  
ã¨ã‚Šã‚ãˆãšã€å†å¸°ã®åŸå‹ã‚’æ›¸ã„ã¦ã¿ã¾ã™ã€‚L ã«ã¯å·¦ç«¯ã®æ–‡å­—ã€R ã«ã¯æ®‹ã‚ŠãŒå…¥ã£ã¦ãã¾ã™ã€‚

```typescript
type KebabCase<S extends string> = S extends `${infer L}${infer R}`
  ? `${Lowercase<L>}${KebabCase<R>}`
  : S;
```

R ã«æ³¨ç›®ã™ã‚‹ã¨ R ã®å…ˆé ­ãŒå¤§æ–‡å­—ã®ã¨ãã€camelCase ã¨ CamelCase ä¸¡æ–¹ã§ãƒã‚¤ãƒ•ãƒ³ãŒå…¥ã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚

```typescript
type KebabCase<S extends string> = S extends `${infer L}${infer R}`
  ? R extends å…ˆé ­ãŒå¤§æ–‡å­—
    ? `${Lowercase<L>}-${KebabCase<R>}`
    : `${Lowercase<L>}${KebabCase<R>}`
  : S;
```

[ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html#intrinsic-string-manipulation-types)
ã‚’èª­ã‚€ã¨ã€Capitalize ãŒã„ã„æ„Ÿã˜ã«ä½¿ãˆãã†ãªã®ã§ã“ã‚Œã‚’ä½¿ã£ã¦åˆ¤å®šã—ã¦ã„ãã¾ã™ã€‚

```typescript
type KebabCase<S extends string> = S extends `${infer L}${infer R}`
  ? R extends Capitalize<R>
    ? `${Lowercase<L>}-${KebabCase<R>}`
    : `${Lowercase<L>}${KebabCase<R>}`
  : S;

type A = KebabCase<"FooBarBaz">; // "foo-bar-baz-"
```

ã„ã‚‰ãªã„ã¨ã“ã‚ã«ã‚‚ãƒã‚¤ãƒ•ãƒ³ãŒã¤ã„ã¦ã—ã¾ã„ã¾ã—ãŸã€‚ã‚ˆãè€ƒãˆã‚‹ã¨æœ€çµ‚çš„ã« R ã«ã¯""ãŒå…¥ã£ã¦ãã‚‹ãŸã‚ã€å½“ç„¶

```typescript
type A = "" extends Capitalize<""> ? true : false; // true
```

ã¨ãªã£ã¦ã„ã¾ã—ãŸã€‚ãªã®ã§ã€å…ˆé ­ãŒå¤§æ–‡å­—**ã§ãªã„**ã“ã¨ã‚’åˆ¤å®šã™ã‚‹ã‚ˆã†ã«å¤‰æ›´ã—ã¾ã—ã‚‡ã†ã€‚

```typescript
type KebabCase<S extends string> = S extends `${infer L}${infer R}`
  ? R extends Uncapitalize<R>
    ? `${Lowercase<L>}${KebabCase<R>}`
    : `${Lowercase<L>}-${KebabCase<R>}`
  : S;
```

## çµ‚ã‚ã‚Šã«

é•·ã„é§„æ–‡ã‚’ã“ã“ã¾ã§èª­ã‚“ã§ãã ã•ã‚Šã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ã€‚

ãã‚ãã‚å¤œãŒæ˜ã‘ã¦æ¥ã¦ã—ã¾ã£ãŸã®ã§ã€ä»Šå›ã¯ã“ã“ã§çµ‚ã‚ã‚Šã«ã—ã‚ˆã†ã¨æ€ã„ã¾ã™ã€‚  
å•é¡Œã‚’è§£ã„ã¦ã„ãã¨ã€è‡ªåˆ†ãŒçŸ¥ã‚‰ãªã‹ã£ãŸçŸ¥è­˜ã‚„ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯ãŒè¦‹ã«ã¤ã„ã¦ã„ã£ã¦ã¨ã¦ã‚‚æ¥½ã—ã„ã§ã™ã€‚  
ã§ã™ãŒã€ã¾ã è‰¯ãã‚ã‹ã£ã¦ã„ãªã„ã¨ã“ã‚(Permutation ç­‰)ã‚‚å¤šãæ®‹ã£ã¦ã„ã‚‹ã®ã§æ™‚é–“ãŒã‚ã‚‹ã¨ãã«èª¿ã¹ã¦ã€ãã£ã¡ã‚Šç†è§£ã§ãã‚‹ã‚ˆã†ã«ã—ã¾ã™ã€‚

ã‚‚ã—ã€è¨˜äº‹å†…å®¹ã«èª¤ã‚Šç­‰ãŒã‚ã‚Œã° Issue ã‚’ã ã—ã¦ã„ãŸã ãã‹ã€ç§ã® DM ã«ãŠé¡˜ã„ã—ã¾ã™ã€‚

æ®‹ã‚Šã®å•é¡Œã¯æ˜æ—¥ä»¥é™è§£ãã¾ã™ã€‚
