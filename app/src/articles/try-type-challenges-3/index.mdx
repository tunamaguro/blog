---
title: "type-challenges ã‚’ã‚„ã£ã¦ã¿ã‚‹(mediumç·¨ãã®2)"
date: "2023-01-08"
slug: "try-type-challenges-3"
emoji: "ğŸ“"
tags: ["tech", "Typescript"]
---

Typescript ã®ç·´ç¿’ã¨ã—ã¦ type-challenges ã‚’ã‚„ã£ãŸå‚™å¿˜éŒ²ã§ã™ã€‚

[type-challenges ã®ãƒªãƒã‚¸ãƒˆãƒª](https://github.com/type-challenges/type-challenges)

[å‰å›](/articles/try-type-challenges-2/)ã®ç¶šãã‚’ã‚„ã£ã¦ã„ãã¾ã™ã€‚

## Diff

Get an Object that is the difference between O & O1

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00645-medium-diff/README.md)

### è§£ç­”ä¾‹

```typescript
type Diff<O, O1> = {
  [P in
    | Exclude<keyof O, keyof O1>
    | Exclude<keyof O1, keyof O>]: P extends keyof O
    ? O[P]
    : P extends keyof O1
    ? O1[P]
    : never;
};
```

ãŠäº’ã„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã§é‡è¤‡ã—ã¦ã„ãªã„ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã®ã¿å–ã‚Šå‡ºã™å•é¡Œã§ã™ã€‚
å˜ç´”ã« keyof O,keyof O1 ä¸¡æ–¹ã‹ã‚‰å‰²ã‚Šå½“ã¦å¯èƒ½ãªå‹ã‚’é™¤ãã€ãã‚Œã‚’ Mapped Types ã§ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå‹ã«ã¾ã¨ã‚ã¾ã™ã€‚  
ä½¿ç”¨ã—ã¦ã„ã‚‹æ©Ÿèƒ½ã®è©³ç´°ã¯ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

1. [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)
1. [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html)
1. [Indexed Access Types](https://www.typescriptlang.org/docs/handbook/2/indexed-access-types.html)
1. [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html)
1. [Exclude(Utility Types)](https://www.typescriptlang.org/docs/handbook/utility-types.html)

## AnyOf

Implement Python liked any function in the type system. A type takes the Array and returns true if any element of the Array is true. If the Array is empty, return false.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/00949-medium-anyof/README.md)

### è§£ç­”ä¾‹

```typescript
type Falsy = [0, "", false, [], Record<any, never>, null, undefined][number];
type AnyOf<T extends readonly any[]> = T extends [infer L, ...infer R]
  ? L extends Falsy
    ? AnyOf<R>
    : true
  : false;
```

T ã®ä¸­ã« javascript ã® Falsy ã®ã‚ˆã†ãªå‹ãŒå­˜åœ¨ã™ã‚‹ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹å•é¡Œã§ã™ã€‚

[Falsy(MDN)](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)

æœ€åˆã«æ€ã„ã¤ã„ãŸã®ã¯ä¸‹ã®ã‚ˆã†ãªå½¢ã§ã—ãŸãŒã€äºˆæƒ³ã¨ã¯ç•°ãªã‚Š false ãŒè¿”ã£ã¦ãã¦ã„ã¾ã—ãŸã€‚

```typescript
type Falsy = [0, "", false, [], {}, null, undefined][number];
type AnyOf<T extends readonly any[]> = T extends [infer L, ...infer R]
  ? L extends Falsy
    ? AnyOf<R>
    : true
  : false;

type A = AnyOf<[1, "test", true, [1], { name: "test" }, { 1: "test" }]>; // false
```

èª¿ã¹ãŸã¨ã“ã‚ã€\{}ãŒã‹ãªã‚Šç‰¹æ®Šãªæ–¹ã®ã‚ˆã†ã§ã™ã€‚

```typescript
type IsEmpty<T> = T extends {} ? true : false;

// falseãªã‚„ã¤ã‚‰
type C = IsEmpty<null>;
type D = IsEmpty<undefined>;

// trueãªã‚„ã¤ã‚‰
type E = IsEmpty<false>;
type F = IsEmpty<number>;
type G = IsEmpty<string>;
type H = IsEmpty<[]>;
type I = IsEmpty<[null]>;
type J = IsEmpty<[number]>;
type K = IsEmpty<{}>;
type L = IsEmpty<{ aaa: string }>;
type M = IsEmpty<{ aaa: null }>;
```

ãã“ã§ \{} ã®ä»£ã‚ã‚Šã« Record\<any,never>ã‚’ä½¿ã£ã¦ç©ºã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¡¨ç¾ã—ã¾ã™ã€‚

```typescript
type IsEmpty<T> = T extends Record<any, never> ? true : false;

// falseãªã‚„ã¤ã‚‰
type C = IsEmpty<null>;
type D = IsEmpty<undefined>;
type E = IsEmpty<false>;
type F = IsEmpty<number>;
type G = IsEmpty<string>;
type H = IsEmpty<[]>;
type I = IsEmpty<[null]>;
type J = IsEmpty<[number]>;
type L = IsEmpty<{ aaa: string }>;
type M = IsEmpty<{ aaa: null }>;

// trueãªã‚„ã¤ã‚‰
type K = IsEmpty<{}>;
```

uhyo æ§˜ãŒè¨˜äº‹ã‚’æ›¸ã‹ã‚Œã¦ã„ã¾ã—ãŸ

[TypeScript ã®å‹å…¥é–€](https://qiita.com/uhyo/items/e2fdef2d3236b9bfe74a#object%E5%9E%8B%E3%81%A8%E5%9E%8B)

## IsNever

Implement a type IsNever, which takes input type T. If the type of resolves to never, return true, otherwise false.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/01042-medium-isnever/README.md)

### è§£ç­”ä¾‹

```typescript
type IsNever<T> = [T] extends [never] ? true : false;
```

T ãŒ never ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹å•é¡Œã§ã™ã€‚ãã®ã¾ã¾æ›¸ãã¨ä¸‹ã®ã‚ˆã†ã«ã‚¨ãƒ©ãƒ¼ãŒã§ã¦ã—ã¾ã„ã¾ã—ãŸã€‚

```typescript
type IsNever<T> = T extends never ? true : false;

type A = IsNever<never>; // never
```

T extends ...ã® T ãŒ never ã ã¨ä½•ãŒã‚ã£ã¦ã‚‚ never ã«åˆ†é¡ã•ã‚Œã‚‹ã‚ˆã†ã§ã™ã€‚

1. [Distributive Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types)
2. [T ãŒ never ã®æ™‚ã®ã€T extends .. ã¯ã€å•ç­”ç„¡ç”¨ã§ never ã«ãªã‚‹](https://scrapbox.io/mrsekut-p/T_%E3%81%8Cnever%E3%81%AE%E6%99%82%E3%81%AE%E3%80%81T_extends_.._%E3%81%AF%E3%80%81%E5%95%8F%E7%AD%94%E7%84%A1%E7%94%A8%E3%81%A7never%E3%81%AB%E3%81%AA%E3%82%8B)

ãªã®ã§ã€[T]ã¨ã—ã¦ã€never ã§ã¯ãªã[never]ã¨ã—ã¦åˆ¤å®šã•ã›ã‚‹ã‚ˆã†ã«ã™ã‚Œã°ã€ã‚¨ãƒ©ãƒ¼ã‚’è§£æ±ºã§ãã¾ã—ãŸã€‚

## IsUnion

Implement a type IsUnion, which takes an input type T and returns whether T resolves to a union type.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/01097-medium-isunion/README.md)

### è§£ç­”ä¾‹

```typescript
type IsUnion<T, U = T> = [T] extends [never]
  ? false
  : T extends never
  ? never
  : U[] extends T[]
  ? false
  : true;
```

T ãŒãƒ¦ãƒ‹ã‚ªãƒ³å‹ã‹ã©ã†ã‹åˆ¤å®šã™ã‚‹å•é¡Œã§ã™ã€‚ä¸Šã§å°‘ã—ã§ã¦ããŸ Distributive Conditional Types ã‚’æ´»ç”¨ã—ã¾ã™ã€‚  
ã¯ã˜ã‚ã«ä¸‹ã®ã‚ˆã†ã«ãŸã åˆ†é…ã™ã‚‹ã ã‘ã®å‹ã‚’ä½œã‚Šã¾ã™ã€‚

```typescript
type IsUnion<T> = T extends never ? never : T[];

type A = IsUnion<string | number>; // string[] | number[]
```

ã™ã‚‹ã¨ T ãŒãƒ¦ãƒ‹ã‚ªãƒ³å‹ã®å ´åˆåˆ†é…ã•ã‚Œã‚‹ã®ã§ã€åˆ†é…ã•ã‚Œã‚‹å‰ã® T[]ã¨æ¯”è¼ƒã™ã‚Œã°åˆ¤å®šã§ããã†ã§ã™ã€‚

```typescript
type IsUnion<T, U = T> = T extends never
  ? never
  : U[] extends T[]
  ? false
  : true;

type A = IsUnion<string | number>;
// = (string | number)[] extends string[] ? false : true
//  |(string | number)[] extends number[] ? false : true
// = true | true
// = true

type B = IsUnion<never>; // never
```

æœ€å¾Œã« never ãŒä¸ãˆã‚‰ã‚ŒãŸå ´åˆã«ã€false ã‚’è¿”ã™ã‚ˆã†ã«ä¸Šã® IsNever ã‚’ãƒ™ãƒ¼ã‚¹ã«æ¡ä»¶åˆ†å²ã‚’è¿½åŠ ã—ã¾ã™ã€‚

```typescript
type IsUnion<T, U = T> = [T] extends [never]
  ? false // T=never
  : T extends never
  ? never
  : U[] extends T[]
  ? false // T = Not Union
  : true; // T = Union
```

## ReplaceKeys

Implement a type ReplaceKeys, that replace keys in union types, if some type has not this key, just skip replacing, A type takes three arguments.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/01130-medium-replacekeys/README.md)

### è§£ç­”ä¾‹

```typescript
type ReplaceKeys<U, T, Y extends Record<any, unknown>> = U extends never
  ? never
  : {
      [P in keyof U]: P extends T ? (P extends keyof Y ? Y[P] : never) : U[P];
    };
```

ã¯ã˜ã‚ã«ã€U ãŒä¸€æ—¦ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã§ã¯ãªã„ã¨ã—ã¦è€ƒãˆã¾ã™ã€‚ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ã‚’è¦‹ã‚‹ã¨æ¬¡ã®ã‚ˆã†ãªå‡¦ç†ã‚’çµ„ã‚ã°è‰¯ã•ãã†ã§ã™ã€‚

1. U ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‹ã‚‰ T ã«å‰²ã‚Šå½“ã¦å¯èƒ½ãªã‚‚ã®ã‚’æ¢ã™
2. T ãŒ Y ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã«å­˜åœ¨ã™ã‚Œã° Y ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£å‹ã€å­˜åœ¨ã—ãªã‘ã‚Œã° never å‹ã«ç½®ãæ›ãˆã‚‹

ã‚„ã‚ŠãŸã„ã“ã¨ã¯ã‚ã‹ã£ãŸã®ã§ã“ã‚Œã‚’å®Ÿè£…ã—ã¾ã™ã€‚ãŠãã‚‰ãã€ä¸‹ã®ã‚ˆã†ãªå½¢ã«ãªã‚‹ã§ã—ã‚‡ã†ã‹ã€‚

```typescript
type ReplaceKeys<U, T, Y extends Record<any, unknown>> = {
  [P in keyof U]: P extends T ? (P extends keyof Y ? Y[P] : never) : U[P];
};
```

æœ€å¾Œã«ã“ã‚Œã‚’ãƒ¦ãƒ‹ã‚ªãƒ³å‹ã§ã‚‚å‡ºæ¥ã‚ˆã†ã§ãã‚‹ã‚ˆã†ã«ã€T ã‚’ Conditional Types ã§åˆ†è§£ã—ã¾ã™ã€‚

```typescript
type ReplaceKeys<U, T, Y extends Record<any, unknown>> = U extends never
  ? never // çµ¶å¯¾ã“ã“ã«ã¯æ¥ãªã„
  : {
      [P in keyof U]: P extends T ? (P extends keyof Y ? Y[P] : never) : U[P];
    };
```

## Remove Index Signature

Implement RemoveIndexSignature\<T> , exclude the index signature from object types.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/01367-medium-remove-index-signature/README.md)

### è§£ç­”ä¾‹

```typescript

```

ã©ã†è€ƒãˆã¦ã‚‚ keyof ã‚’ä½¿ã†å•é¡Œã§ã™ãŒã€Index Signatures ã« keyof ã‚’ä½¿ã£ãŸã¨ãã®å‹•ä½œãŒã‚ã‹ã‚‰ãªã‹ã£ãŸã®ã§ã¨ã‚Šã‚ãˆãšèª¿ã¹ã¦ã¿ã¾ã™ã€‚

1. [Index Signatures](https://www.typescriptlang.org/docs/handbook/2/objects.html#index-signatures)
2. [Keyof Type Operator](https://www.typescriptlang.org/docs/handbook/2/keyof-types.html)

è‹±èªãŒã§ããªã„ã®ã§ã€é›°å›²æ°—ã§èª­ã‚“ã§ã¿ã‚‹ã¨ Index Signatures ã« number ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆ keyof ã¯ number ã‚’ã€
string ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ string | number ã‚’è¿”ã™ã‚ˆã†ã§ã™ã€‚

> ```typescript
> type Arrayish = { [n: number]: unknown };
> type A = keyof Arrayish; // number
> type Mapish = { [k: string]: boolean };
> type M = keyof Mapish; // string | number
> ```
>
> Note that in this example, M is string | number â€” this is because JavaScript object keys are always coerced to a string, so obj[0] is always the same as obj["0"].

ã—ã‹ã—ã€symbol ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹å ´åˆã®èª¬æ˜ãŒãªã„ã®ã§ã€ä¸€å›è©¦ã—ã¦ã¿ã¾ã™ã€‚çµæœãŒä¸‹ã§ã™ã€‚

```typescript
type Check<T> = { [P in keyof T]: P };

type Foo = {
  [key: string]: any;
  foo(): void;
};

type Bar = {
  [key: number]: any;
  bar(): void;
  0: string;
};

const foobar = Symbol("foobar");

type FooBar = {
  [key: symbol]: any;
  [foobar](): void;
};

type Baz = {
  bar(): void;
  baz: string;
};

type A = Check<Foo>;
// type A = {
//     [x: string]: string;
//     foo: "foo";
// }

type B = Check<Bar>;
// type B = {
//     [x: number]: number;
//     bar: "bar";
//     0: 0;
// }

type C = Check<FooBar>;
// type C = {
//     [x: symbol]: symbol;
//     [foobar]: typeof foobar;
// }
type D = Check<Baz>;
// type D = {
//     bar: "bar";
//     baz: "baz";
// }
```

string ãŒè¨­å®šã•ã‚Œã¦ã„ã‚‹ã¨ãã« string | number ãŒè¿”ã£ã¦ãã¦ã„ãªã„æ°—ãŒã—ã¾ã™ãŒã€ã²ã¨ã¾ãš symbol ã®å ´åˆã¯ symbol ãŒè¿”ã£ã¦ãã‚‹ã‚ˆã†ã§ã™ã€‚  
ã“ã“ã¾ã§ã®æ¤œè¨¼ã‚’ã¾ã¨ã‚ã‚‹ã¨ Index Signatures ã« keyof ã‚’ä½¿ã†ã¨ string | number | symbol ã®ã©ã‚Œã‹ãŒè¿”ã£ã¦ãã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã—ãŸã€‚

ã¨ã„ã†ã“ã¨ã§ã€ã¨ã‚Šã‚ãˆãš Index Signatures ãŒ never ã«ãªã‚‹ã‚ˆã†ãªå‹ã‚’ä½œã£ã¦ã¿ã¾ã™ã€‚

```typescript
type RemoveIndexSignature<T> = {
  [P in keyof T]: string extends P
    ? never
    : number extends P
    ? never
    : symbol extends P
    ? never
    : T[P];
};

type B = RemoveIndexSignature<Bar>;
// type B = {
//     [x: number]: never;
//     bar: () => void;
//     0: string;
// }
type C = RemoveIndexSignature<FooBar>;
// type C = {
//     [x: symbol]: never;
//     [foobar]: () => void;
// }
```

ã“ã“ã§ã€Mapped Types ã§ä½¿ç”¨ã§ãã‚‹ as ã‚’ä½¿ã„ã¾ã™ã€‚as ã‚’ä½¿ã†ã“ã¨ã§ \{[P in T]:...}ã¨ã—ã¦ã„ãŸ P ã«å¯¾ã—ã¦å¤‰æ›´ã‚’åŠ ãˆã‚‰ã‚Œã¾ã™ã€‚

[Key Remapping via as](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html#key-remapping-via-as)

```typescript
type RemoveIndexSignature<T> = {
  [P in keyof T as string extends P
    ? never
    : number extends P
    ? never
    : symbol extends P
    ? never
    : P]: T[P];
};
```

as ã‚’ä½¿ã‚ãªãã¦ã‚‚ keyof T ã®ã†ã¡ T[P]ãŒ never ãªã‚‚ã®ã‚’å–ã‚Šé™¤ãã€ãã‚Œã‚’ä½¿ã£ã¦ T ã‚’å†æ§‹æˆã™ã‚Œã°è¡Œã‘ã‚‹ã¨æ€ã„ã¾ã™ãŒæœªæ¤œè¨¼ã§ã™ã€‚

## Percentage Parser

Implement PercentageParser. According to the /^(\+|\-)?(\d\*)?(\%)?$/ regularity to match T and get three matches.

The structure should be: [plus or minus, number, unit] If it is not captured, the default is an empty string.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/01978-medium-percentage-parser/README.md)

### è§£ç­”ä¾‹

```typescript

```

ã“ã®å•é¡Œã¯ï¼“ã¤ã®å·¥ç¨‹ã«åˆ†è§£ã—ã¦è€ƒãˆã¾ã™ã€‚

1. ç¬¦å·ãŒã¤ã„ã¦ã„ã‚‹ã‹åˆ¤å®šã€‚ã¤ã„ã¦ã„ãŸã‚‰ãã®ç¬¦å·ã‚’è¿”ã™
2. %ãŒã¤ã„ã¦ã„ã‚‹ã‹åˆ¤å®šã€‚ã¤ã„ã¦ã„ã‚Œã°%ã‚’è¿”ã™
3. æ•°å­—éƒ¨åˆ†ã‚’å–ã‚Šå‡ºã™

ã¾ãšã€1 ã¨ 2 ã®åˆ¤å®šéƒ¨åˆ†ã‚’ä½œã‚Šã¾ã™ã€‚ã“ã‚Œã¯ã‚µã‚¯ãƒƒã¨ä½œã‚Œã‚‹ã§ã—ã‚‡ã†ã€‚

```typescript
type ParseSign<A extends string> = A extends `${"+" | "-"}${string}`
  ? A extends `${infer L}${string}`
    ? L
    : never
  : "";

type ParsePercentage<A extends string> = A extends `${string}%` ? "%" : "";
```

æ¬¡ã«ã“ã‚Œã‚‰ã‚’çµ„ã¿åˆã‚ã›ã¦ã€3 ã®æ•°å­—å–ã‚Šå‡ºã—ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

```typescript
type PercentageParser<
  A extends string,
  S extends string = ParseSign<A>,
  P extends string = ParsePercentage<A>
> = A extends `${S}${infer N}${P}` ? [S, N, P] : never;

type A = PercentageParser<"+100%">;
```

## Drop Char

Drop a specified char from a string.

[å•é¡Œ](https://github.com/type-challenges/type-challenges/blob/main/questions/02070-medium-drop-char/README.md)

### è§£ç­”ä¾‹

```typescript
type DropChar<
  S extends string,
  C extends string,
  V extends string = ""
> = S extends ""
  ? V
  : S extends `${infer L}${infer R}`
  ? L extends C
    ? DropChar<R, C, V>
    : DropChar<R, C, `${V}${L}`>
  : never;
```

æœ¬å½“ã¯ C ãŒ 1 æ–‡å­—ã‹ã©ã†ã‹ã®æ¤œè¨¼ã‚’å…¥ã‚Œã‚‹ã¹ãã ã¨æ€ã„ã¾ã™ãŒã€Drop **Char** ãªã®ã§è¦‹ãªã‹ã£ãŸã“ã¨ã«ã—ã¾ã™ã€‚

## çµ‚ã‚ã‚Šã«

ä»Šæ—¥ã¯æ™‚é–“ãŒã¨ã‚Œãªã‹ã£ãŸã®ã«åŠ ãˆã¦ã€å•é¡Œè‡ªä½“ã®é›£æ˜“åº¦ã‚‚ä¸ŠãŒã‚Šæ˜¨æ—¥ã¨æ¯”è¼ƒã—ã¦ 3 åˆ†ã® 1 ã—ã‹è§£ãã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ(ä»Šæ—¥ 8 å•ã€æ˜¨æ—¥ 24 å•)ã€‚

å•é¡Œã®é›£æ˜“åº¦ãŒä¸ŠãŒã£ãŸã¶ã‚“ã€è‡ªåˆ†ã® Typesript ç­‹ãŒå¼·ããªã£ã¦ã„ã£ã¦ã„ã‚‹ã¨ã‚ã‚ŠãŒãŸã„ã§ã™ãŒ...

ã‚‚ã—ã€è¨˜äº‹å†…å®¹ã«èª¤ã‚Šç­‰ãŒã‚ã‚Œã° Issue ã‚’ã ã—ã¦ã„ãŸã ãã‹ã€ç§ã® DM ã«ãŠé¡˜ã„ã—ã¾ã™ã€‚

æ®‹ã‚Šã®å•é¡Œã¯æ˜æ—¥ä»¥é™è§£ãã¾ã™ã€‚
